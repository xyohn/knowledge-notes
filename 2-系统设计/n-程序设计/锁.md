# 锁

1. 是什么

   1. 一种共享资源保护的方式，任何时间都只能有一个线程持有某个锁，且只有持有锁的线程才能访问被保护资源

2. 为什么

   1. 多线程在并行执行的时候，并发读写共享数据，可能会产出不可预期的结果

3. 使用原则

   1. 避免滥用锁

      > 能不用锁，就不用锁
      >
      > 不确定是不是应该用锁，那也不要用锁

      1. 存在性能损失

         * 加锁和解锁过程需要 CPU 时间

         * 线程等待锁过程处于阻塞的状态，过多的锁等待会显著降低程序的性能

      2. 容易造成死锁

         * 对锁使用不当使得程序更难调试

      只有在并发环境中，共享资源不支持并发访问，或者说并发访问共享资源会导致系统错误的情况下，才需要使用锁

   2. 使用读写锁代替锁

      > 对于读远大于写的业务，使用读写锁可以显著提高读的性能
      >
      > 读读锁之间不互斥，有效兼顾性能和安全

      1. 相对优势
         * 读访问可以并发执行

4. 使用方法

   * 在访问共享资源之前，先获取锁。

   * 如果获取锁成功，允许访问共享资源，否则等待、重试或退出。

   * 使用完毕后需要释放锁，以便其他线程继续访问共享资源。

     > 要考虑执行异常情况下仍能退出锁

5. 死锁的产生和避免

   1. 产生条件

      * 互斥

        > 进程应互斥且排他的使用

      * 占有和等待条件

        > 进程在请求资源得不到满足而等待时，不释放已占有资源

      * 不剥夺条件

        > 已获资源只能自愿释放，不允许被其他进程剥夺

      * 循环等待条件

        > 每个进程都在等待链中等待下一个进程所持有的资源

   2. 产生场景

      * 未正确释放锁

      * 非可重入锁

        > 当前线程不能重复获取同个锁，导致自己等待自己释放锁

      * 加锁顺序不一致

   3. 解决方案

      1. 避免滥用锁

      2. 对于同一把锁，加锁和解锁必须要放在同一个方法中

         > 代码更清晰

      3. 避免在持有一把锁的情况下，去获取另外一把锁

         > 减少同时获取多把锁

      4. 多把锁加锁顺序须一致，解锁顺序与加锁顺序相反

## 参考资料

* 极客时间-消息队列高手课