# 自动内存管理

1. 是什么

   1. 对于内存的使用，不需要显式去申请和释放内存，系统会在需要使用时自动分配内存，在使用完毕后择机收回内存
   2. 一种内存管理机制，屏蔽内存管理的复杂性，由系统决定内存分配，无需开发者干预

2. 为什么

   1. 减轻开发者负担，让开发者专注于业务
   2. 有效避免内存泄漏的问题

3. 实现原理

   1. 申请内存

      * 计算要创建对象所需要占用的内存大小
      * 在内存中找一块儿连续并且是空闲的内存空间，标记为已占用
      * 把申请的内存地址绑定到对象的引用上

   2. 回收内存

      * 找出所有可以回收的对象，将对应的内存标记，随后进行清除

        * 标记

          * 可达性分析

            > 从 GC Root 开始，标记所有可达的对象，因为程序中所有在用的对象一定都会被这个 GC Root 对象直接或者间接引用

          * 引用计数

            > 为对象添加引用计数器，用来统计指向该对象的引用个数，引用个数为0的即为没有标记的对象

        * 清除

          > 遍历所有对象，找出所有没有标记的对象。这些没有标记的对象都是可以被回收的，清除这些对象，释放对应的内存

        > 执行标记和清除过程中，必须把进程暂停，否则计算的结果就是不准确的

        > 后续产生了许多更加复杂的变种算法，可减少进程暂停时间，但都不能完全避免暂停进程

      * 整理内存碎片

        > 将不连续的空闲内存移动到一起，以便空出足够的连续内存空间供后续使用
        >
        > 由于整理过程中需要移动内存中的数据，也都不可避免地需要暂停进程

4. 存在的风险

   * 高并发场景下，容易导致服务暂停

     * 请求量增大，每个请求都创建大量对象
     * 对象占满内存，触发垃圾回收
     * 垃圾回收导致进程暂停，积压大量请求等待处理
     * 垃圾回收结束，开始处理积压请求，又有更多请求涌入
     * 请求创建大量对象，对象占满内存，触发垃圾回收...

     > 垃圾回收的速度跟不上创建对象的速度，导致暂停还可能出现内存溢出

5. 优化方案

   * 尽量少产生一次性对象

     > 只有被丢弃的对象才是垃圾回收的目标，因此需要减少创建一次性对象
     >
     > 尤其是占用内存大的对象

   * 回收并重用占用内存较大的一次性对象

     > 对于需要频繁使用的对象，可以考虑建立对象池进行复用

   * 使用更大的内存服务器

     > 加钱

   * 绕开自动垃圾回收机制

     > 根据业务情况自行决定垃圾回收机制，但是会增大程序复杂度，也可能导致内存泄漏的风险

## 参考资料

* 极客时间-消息队列高手课