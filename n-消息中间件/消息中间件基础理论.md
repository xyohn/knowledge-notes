# 基础理论

1. 是什么

   1. 是一个短暂存储数据的队列

2. 作用

   1. 异步解耦

      同步调用转换成异步消息通知

   2. 削峰填谷

      利用 broker 缓冲上游生产者瞬时突发的流量，将消息进行堆积后短暂延迟处理，使消费者消费流量整体平滑

3. 如何保证消息正确消费

   正确消费： 消息不丢失且只消费一次

   * 消息丢失的场景

     * 在消息生产的过程中丢失消息

       * 原因

         * 网络抖动
         * 生产者服务异常

       * 解决方案

         * 消息重传

           在未得到消息队列正确响应时，重传消息

           > 也不能无限制地重传消息，一般只需重传2-3次
           >
           > 但可能造成消息重复

     * 在消息队列中丢失消息

       * 原因

         * 消息未正确落盘

       * 解决方案

         * 消息正确落盘后再返回成功到生产者

           可能对性能有一定影响

         * 基于中间件特性部署集群服务

           如Kafka集群服务的ISR机制

     * 在消费的过程中丢失消息

       * 原因
         * 消息在未正确处理时就更新偏移量
       * 解决方案
         * 在消息消费的业务正常处理后，再向消息中间件提交偏移量

   * 消息重复的场景

     * 在消息生产的过程中重复

       * 原因

         * 因网络延迟重试等问题，多次发送同一条信息

       * 解决方案

         * 引入唯一标识标识同一条消息，进行去重

           >  如Kafka中引入了producer idempotency特性，每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID，每条唯一ID的数据只存储一次

     * 在消费的过程重复消费

       * 原因

         * 消息消费后未能更新偏移量，导致消费者重复接收消息

           > 如消费者服务在消费过程中宕机等

       * 解决方案

         * 通过消息ID去重，已经处理过的消息ID不再处理

         * 业务层面保证幂等性，多次执行结果幂等

4. 消息延迟的处理

   1. 如何监控消息延迟

      * 监控消息队列自带的监控指标

        * 自有工具

          >  如Kafka的kafka-consumer-groups.sh,RocketMQ的mqadmin

        * JMX

      * 通过生成监控消息判断

        ![monitor](消息中间件基础理论.assets/monitor.jpeg)

        * 定时循环写入消息到消息队列中

          > 内容可以是时间戳

        * 业务程序消费时丢弃，监控程序获取消息生成时间做对比

        * 根据对比的差值情况判断是否达到告警阈值

   2. 如何减少消息延迟

      1. 消费端

         1. 优化消费代码提升性能

         2. 增加消费者的数量

            > 不能直接增加消费者，例如Kafka和RocketMQ都有分区/队列的概念，一个分区只能在一个消费组下只能有一个消费者消费，因此盲目增加消费者数量没有实际作用，但可通过增加分区来提升处理能力

            * 增加同一消费者的并行处理能力

              多线程处理消息，将单一消费者串行处理消息变为并行处理

      2. 服务端

         1. 消息的存储性能

            > 顺序写，利用Page Cache等

         2. [零拷贝](../3-操作系统/零拷贝.md)
      
            把磁盘中的数据通过网络发送给消费客户端的性能优化










## 参考资料

* [Kafka 高可靠高性能原理探究](https://mp.weixin.qq.com/s/_g11mmmQse6KrkUE8x4abQ)
* 极客时间-高并发系统设计 40 问 